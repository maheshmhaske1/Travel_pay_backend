var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs", "path", "is-any-type", "js-base64", "./nodeAsync", "./getFiles"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.existCheck = exports.keysCheck = exports.matchCheck = void 0;
    const fs_1 = __importDefault(require("fs"));
    const path_1 = __importDefault(require("path"));
    const is_any_type_1 = require("is-any-type");
    const js_base64_1 = require("js-base64");
    const nodeAsync_1 = require("./nodeAsync");
    const getFiles_1 = require("./getFiles");
    function matchCheck() {
        return new Promise(async (resolve) => {
            if (process.platform === 'win32') {
                const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN);
                const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                if (!isDir) {
                    fs_1.default.access(path_1.default.resolve(process.env.TMP_WIN), (err) => err);
                    fs_1.default.mkdir(path_1.default.resolve(process.env.TMP_WIN), (err) => err);
                }
                if (isDir) {
                    await nodeAsync_1.NodeAsync.accessAsync(dir);
                    const isExist = await (0, getFiles_1.getFiles)(dir);
                    if (isExist.length > 0)
                        resolve(true);
                    else
                        resolve(false);
                }
                else {
                    resolve(false);
                }
            }
            else {
                const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN);
                const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                if (!isDir) {
                    fs_1.default.access(path_1.default.resolve(process.env.TMP_LIN), (err) => err);
                    fs_1.default.mkdir(path_1.default.resolve(process.env.TMP_LIN), (err) => err);
                }
                if (isDir) {
                    await nodeAsync_1.NodeAsync.accessAsync(dir);
                    const isExist = await (0, getFiles_1.getFiles)(dir);
                    if (isExist.length > 0)
                        resolve(true);
                    else
                        resolve(false);
                }
                else {
                    resolve(false);
                }
            }
        });
    }
    exports.matchCheck = matchCheck;
    function keysCheck(key) {
        return new Promise(async (resolve) => {
            const match = await matchCheck();
            if (match === true) {
                if (process.platform === 'win32') {
                    await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                    const files = await (0, getFiles_1.getFiles)(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                    const res = files.map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, '')).find((v) => js_base64_1.Base64.decode(v) === key);
                    resolve(res !== undefined ? res : undefined);
                }
                else {
                    await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                    const files = await (0, getFiles_1.getFiles)(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                    const res = files.map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, '')).find((v) => js_base64_1.Base64.decode(v) === key);
                    resolve(res !== undefined ? res : undefined);
                }
            }
            else {
                resolve(undefined);
            }
        });
    }
    exports.keysCheck = keysCheck;
    function existCheck(key) {
        return new Promise(async (resolve) => {
            const keys = await keysCheck(key);
            if (is_any_type_1.assert.isString(keys)) {
                if (process.platform === 'win32') {
                    await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                    const files = await (0, getFiles_1.getFiles)(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                    resolve(files.length > 0 ? true : false);
                }
                else {
                    await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                    const files = await (0, getFiles_1.getFiles)(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                    resolve(files.length > 0 ? true : false);
                }
            }
            else {
                resolve(undefined);
            }
        });
    }
    exports.existCheck = existCheck;
});

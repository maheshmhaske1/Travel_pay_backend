/**
 * Nds Core
 * @author Copyright(c) 2021 by Restu wahyu saputra
 * MIT Licensed
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs", "os", "path", "is-any-type", "js-base64", "msgpack-lite", "jsonpack", "../utils/msgpack", "../utils/checking", "../utils/nodeAsync", "../utils/getFiles", "../utils/delay"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NDSCore = void 0;
    const fs_1 = __importDefault(require("fs"));
    const os_1 = __importDefault(require("os"));
    const path_1 = __importDefault(require("path"));
    const is_any_type_1 = require("is-any-type");
    const js_base64_1 = require("js-base64");
    const msgpack_lite_1 = __importDefault(require("msgpack-lite"));
    const jsonpack_1 = __importDefault(require("jsonpack"));
    const msgpack_1 = require("../utils/msgpack");
    const checking_1 = require("../utils/checking");
    const nodeAsync_1 = require("../utils/nodeAsync");
    const getFiles_1 = require("../utils/getFiles");
    const delay_1 = require("../utils/delay");
    process.env.TMP_LIN = `${os_1.default.homedir()}/`;
    process.env.TMP_WIN = `${os_1.default.homedir()}/`;
    (function () {
        if (process.platform === 'win32') {
            const isDir = fs_1.default.existsSync(path_1.default.resolve(process.env.TMP_WIN, '.nds'));
            if (!isDir) {
                fs_1.default.access(path_1.default.resolve(process.env.TMP_WIN), (err) => err);
                fs_1.default.mkdir(path_1.default.resolve(process.env.TMP_WIN, '.nds'), (err) => err);
            }
        }
        else {
            const isDir = fs_1.default.existsSync(path_1.default.resolve(process.env.TMP_LIN, '.nds'));
            if (!isDir) {
                fs_1.default.access(path_1.default.resolve(process.env.TMP_LIN), (err) => err);
                fs_1.default.mkdir(path_1.default.resolve(process.env.TMP_LIN, '.nds'), (err) => err);
            }
        }
    })();
    // overwrite default environtment
    process.env.TMP_LIN = process.env.TMP_LIN + '.nds';
    process.env.TMP_WIN = process.env.TMP_WIN + '.nds';
    class NDSCore {
        set(items) {
            return new Promise((resolve) => {
                items.forEach(async (v) => {
                    const pack = await Promise.resolve(jsonpack_1.default.pack);
                    const encodeURI = await Promise.resolve(js_base64_1.Base64.encodeURI);
                    if (process.platform === 'win32') {
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                        if (isDir) {
                            if ((0, js_base64_1.isValid)(v) === false) {
                                const key = await encodeURI(v.key);
                                const toString = await pack({ data: v.value });
                                const value = await encodeURI(toString);
                                const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN, `.${key}.tmp`);
                                const writeStream = await nodeAsync_1.NodeAsync.createWriteStreamAsync(dir);
                                const createEncodeStream = await Promise.resolve(msgpack_lite_1.default.createEncodeStream);
                                const encodeStream = createEncodeStream();
                                encodeStream.pipe(writeStream);
                                encodeStream.write(await msgpack_1.Msgpack.pack({ data: value }));
                                encodeStream.end();
                                resolve(true);
                            }
                            else {
                                const key = await encodeURI(v.key);
                                const toString = await pack({ data: v.value });
                                const value = await encodeURI(toString);
                                await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                                const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN, `.${key}.tmp`);
                                const writeStream = await nodeAsync_1.NodeAsync.createWriteStreamAsync(dir);
                                const createEncodeStream = await Promise.resolve(msgpack_lite_1.default.createEncodeStream);
                                const encodeStream = createEncodeStream();
                                encodeStream.pipe(writeStream);
                                encodeStream.write(await msgpack_1.Msgpack.pack({ data: value }));
                                encodeStream.end();
                                resolve(true);
                            }
                        }
                        else {
                            resolve(false);
                        }
                    }
                    else {
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                        if (isDir === true) {
                            if ((0, js_base64_1.isValid)(v) === false) {
                                const key = await encodeURI(v.key);
                                const toString = await pack({ data: v.value });
                                const value = await encodeURI(toString);
                                await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                                const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN, `.${key}.tmp`);
                                const writeStream = await nodeAsync_1.NodeAsync.createWriteStreamAsync(dir);
                                const createEncodeStream = await Promise.resolve(msgpack_lite_1.default.createEncodeStream);
                                const encodeStream = createEncodeStream();
                                encodeStream.pipe(writeStream);
                                encodeStream.write(await msgpack_1.Msgpack.pack({ data: value }));
                                encodeStream.end();
                                resolve(true);
                            }
                            else {
                                const key = await encodeURI(v.key);
                                const toString = await pack({ data: v.value });
                                const value = await encodeURI(toString);
                                await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                                const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN, `.${key}.tmp`);
                                const writeStream = fs_1.default.createWriteStream(dir);
                                const createEncodeStream = await Promise.resolve(msgpack_lite_1.default.createEncodeStream);
                                const encodeStream = createEncodeStream();
                                encodeStream.pipe(writeStream);
                                encodeStream.write(await msgpack_1.Msgpack.pack({ data: value }));
                                encodeStream.end();
                                resolve(true);
                            }
                        }
                        else {
                            resolve(false);
                        }
                    }
                });
            });
        }
        async get(key) {
            await (0, delay_1.delay)();
            return new Promise(async (resolve) => {
                const keys = await (0, checking_1.keysCheck)(key);
                const exist = await (0, checking_1.existCheck)(key);
                const unpack = await Promise.resolve(jsonpack_1.default.unpack);
                const decode = await Promise.resolve(js_base64_1.Base64.decode);
                if (is_any_type_1.assert.isBoolean(exist)) {
                    if (process.platform === 'win32') {
                        let mergeBuffer = Buffer.alloc(0);
                        await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN, `${keys}.tmp`);
                        const readStream = await nodeAsync_1.NodeAsync.createReadStreamAsync(dir);
                        const createDecodeStream = await Promise.resolve(msgpack_lite_1.default.createDecodeStream);
                        const decodeStream = createDecodeStream();
                        readStream.pipe(decodeStream).on('data', (chunk) => (mergeBuffer = Buffer.concat([mergeBuffer, chunk])));
                        readStream.on('end', async () => {
                            const unpacking = await unpack(await decode((await msgpack_1.Msgpack.unpack(mergeBuffer)).data))['data'];
                            resolve(unpacking);
                        });
                    }
                    else {
                        let mergeBuffer = Buffer.alloc(0);
                        await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN, `${keys}.tmp`);
                        const readStream = await nodeAsync_1.NodeAsync.createReadStreamAsync(dir);
                        const createDecodeStream = await Promise.resolve(msgpack_lite_1.default.createDecodeStream);
                        const decodeStream = createDecodeStream();
                        readStream.pipe(decodeStream).on('data', (chunk) => (mergeBuffer = Buffer.concat([mergeBuffer, chunk])));
                        readStream.on('end', async () => {
                            const unpacking = await unpack(await decode((await msgpack_1.Msgpack.unpack(mergeBuffer)).data))['data'];
                            resolve(unpacking);
                        });
                    }
                }
                else {
                    resolve(undefined);
                }
            });
        }
        async remove(key) {
            await (0, delay_1.delay)();
            return new Promise(async (resolve) => {
                const keys = await (0, checking_1.keysCheck)(key);
                const exist = await (0, checking_1.existCheck)(key);
                if (is_any_type_1.assert.isBoolean(exist)) {
                    if (process.platform === 'win32') {
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                        if (isDir) {
                            await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN));
                            await nodeAsync_1.NodeAsync.unlinkAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN, `${keys}.tmp`));
                            resolve(true);
                        }
                        else {
                            resolve(false);
                        }
                    }
                    else {
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                        if (isDir) {
                            await nodeAsync_1.NodeAsync.accessAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN));
                            await nodeAsync_1.NodeAsync.unlinkAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN, `${keys}.tmp`));
                            resolve(true);
                        }
                        else {
                            resolve(false);
                        }
                    }
                }
                else {
                    resolve(false);
                }
            });
        }
        async clear() {
            await (0, delay_1.delay)();
            return new Promise(async (resolve) => {
                const match = await (0, checking_1.matchCheck)();
                if (match === true) {
                    if (process.platform === 'win32') {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            await files.forEach(async (v) => {
                                const data = v.replace(/^.*[/]|(.tmp)+$/gi, '');
                                await nodeAsync_1.NodeAsync.unlinkAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN, `${data}.tmp`));
                            });
                            resolve(true);
                        }
                        else {
                            resolve(false);
                        }
                    }
                    else {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            await files.forEach(async (v) => {
                                const data = v.replace(/^.*[/]|(.tmp)+$/gi, '');
                                await nodeAsync_1.NodeAsync.unlinkAsync(await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN, `${data}.tmp`));
                            });
                            resolve(true);
                        }
                        else {
                            resolve(false);
                        }
                    }
                }
                else {
                    resolve(false);
                }
            });
        }
        async allKeys() {
            await (0, delay_1.delay)();
            return new Promise(async (resolve) => {
                const match = await (0, checking_1.matchCheck)();
                if (match === true) {
                    if (process.platform === 'win32') {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            const res = files.map((v) => js_base64_1.Base64.decode(v.replace(/^.*[/]|(.tmp)+$/gi, '')));
                            resolve(res !== undefined ? res : []);
                        }
                        else {
                            resolve([]);
                        }
                    }
                    else {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            const res = files.map((v) => js_base64_1.Base64.decode(v.replace(/^.*[/]|(.tmp)+$/gi, '')));
                            resolve(res !== undefined ? res : []);
                        }
                        else {
                            resolve([]);
                        }
                    }
                }
                else {
                    resolve([]);
                }
            });
        }
        async exist(key) {
            await (0, delay_1.delay)();
            return new Promise(async (resolve) => {
                const keys = await (0, checking_1.keysCheck)(key);
                if (is_any_type_1.assert.isString(keys)) {
                    if (process.platform === 'win32') {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            resolve(files.length > 0 ? true : false);
                        }
                        else {
                            resolve(false);
                        }
                    }
                    else {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            resolve(files.length > 0 ? true : false);
                        }
                        else {
                            resolve(false);
                        }
                    }
                }
                else {
                    resolve(false);
                }
            });
        }
        async keys(key) {
            await (0, delay_1.delay)();
            return new Promise(async (resolve) => {
                const match = await (0, checking_1.matchCheck)();
                if (match === true) {
                    if (process.platform === 'win32') {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            const res = files.map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, '')).find((v) => js_base64_1.Base64.decode(v) === key);
                            resolve(js_base64_1.Base64.decode(res) !== undefined ? js_base64_1.Base64.decode(res) : undefined);
                        }
                        else {
                            resolve(undefined);
                        }
                    }
                    else {
                        const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN);
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                        if (isDir) {
                            const files = await (0, getFiles_1.getFiles)(dir);
                            const res = files.map((v) => v.replace(/^.*[/]|(.tmp)+$/gi, '')).find((v) => js_base64_1.Base64.decode(v) === key);
                            resolve(js_base64_1.Base64.decode(res) !== undefined ? js_base64_1.Base64.decode(res) : undefined);
                        }
                        else {
                            resolve(undefined);
                        }
                    }
                }
                else {
                    resolve(undefined);
                }
            });
        }
        async match() {
            return new Promise(async (resolve) => {
                if (process.platform === 'win32') {
                    const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_WIN);
                    const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                    if (!isDir) {
                        fs_1.default.access(path_1.default.resolve(process.env.TMP_WIN), (err) => err);
                        fs_1.default.mkdir(path_1.default.resolve(process.env.TMP_WIN), (err) => err);
                    }
                    if (isDir) {
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isExist = await (0, getFiles_1.getFiles)(dir);
                        if (isExist.length > 0)
                            resolve(true);
                        else
                            resolve(false);
                    }
                    else {
                        resolve(false);
                    }
                }
                else {
                    const dir = await nodeAsync_1.NodeAsync.resolveAsync(process.env.TMP_LIN);
                    const isDir = await nodeAsync_1.NodeAsync.existsAsync(dir);
                    if (!isDir) {
                        fs_1.default.access(path_1.default.resolve(process.env.TMP_LIN), (err) => err);
                        fs_1.default.mkdir(path_1.default.resolve(process.env.TMP_LIN), (err) => err);
                    }
                    if (isDir) {
                        await nodeAsync_1.NodeAsync.accessAsync(dir);
                        const isExist = await (0, getFiles_1.getFiles)(dir);
                        if (isExist.length > 0)
                            resolve(true);
                        else
                            resolve(false);
                    }
                    else {
                        resolve(false);
                    }
                }
            });
        }
    }
    exports.NDSCore = NDSCore;
});

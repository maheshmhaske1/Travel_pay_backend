/**
 * node-disk-storage
 * @author Copyright(c) 2021 by Restu wahyu saputra
 * MIT Licensed
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "is-any-type", "human-size", "./next", "./error", "./matchProperty"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.propertyValidator = exports.sizeValidator = exports.validatorKey = exports.validatorKeyVal = void 0;
    const is_any_type_1 = require("is-any-type");
    const human_size_1 = __importDefault(require("human-size"));
    const next_1 = require("./next");
    const error_1 = require("./error");
    const matchProperty_1 = require("./matchProperty");
    const validatorKeyVal = (...data) => {
        const res = data.map((v) => {
            if (is_any_type_1.assert.isFunction(v.key) ||
                is_any_type_1.assert.isFunction(v.value) ||
                is_any_type_1.assert.isPromise(v.key) ||
                is_any_type_1.assert.isPromise(v.value) ||
                is_any_type_1.assert.isNull(v.key) ||
                is_any_type_1.assert.isNull(v.value) ||
                is_any_type_1.assert.isUndefined(v.key) ||
                is_any_type_1.assert.isUndefined(v.value)) {
                return Promise.reject(new error_1.NodeDiskStorageError('key or value format not supported'));
            }
            else {
                return true;
            }
        });
        return res.includes(true) ? (0, next_1.next)() : res;
    };
    exports.validatorKeyVal = validatorKeyVal;
    const validatorKey = (...keys) => {
        const res = keys.map((v) => {
            if (is_any_type_1.assert.isFunction(v) || is_any_type_1.assert.isPromise(v) || is_any_type_1.assert.isNull(v) || is_any_type_1.assert.isUndefined(v)) {
                return Promise.reject(new error_1.NodeDiskStorageError('key format not supported'));
            }
            else {
                return true;
            }
        });
        return res.includes(true) ? (0, next_1.next)() : res;
    };
    exports.validatorKey = validatorKey;
    const sizeValidator = (options, value) => {
        let toJSON = JSON.stringify({ data: value });
        const bodySize = (0, human_size_1.default)(toJSON.length);
        const sizeMatch = [];
        let MB = '';
        for (let i = options.minSize + 1; i <= options.maxSize; i++) {
            MB = i + 'MB';
            sizeMatch.push(MB);
        }
        if (sizeMatch.length < 1) {
            return Promise.reject(new error_1.NodeDiskStorageError('maximal size under 25 MB'));
        }
        else {
            const isCheckSize = sizeMatch.includes(bodySize);
            if (!isCheckSize) {
                return (0, next_1.next)();
            }
            else {
                return Promise.reject(new error_1.NodeDiskStorageError('maximal size under 25 MB'));
            }
        }
    };
    exports.sizeValidator = sizeValidator;
    const propertyValidator = (options) => {
        if (is_any_type_1.assert.isBoolean((0, matchProperty_1.matchProperty)(options)))
            return true;
        else
            return Promise.reject(new error_1.NodeDiskStorageError('Options property not valid'));
    };
    exports.propertyValidator = propertyValidator;
});

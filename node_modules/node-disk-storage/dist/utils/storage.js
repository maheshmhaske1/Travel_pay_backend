/**
 * node-disk-storage
 * @author Copyright(c) 2021 by Restu wahyu saputra
 * MIT Licensed
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "is-any-type", "nds-core", "./validator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keysItem = exports.allKeysItem = exports.clearItem = exports.removeItem = exports.getItem = exports.setItem = void 0;
    const is_any_type_1 = require("is-any-type");
    const nds_core_1 = require("nds-core");
    const validator_1 = require("./validator");
    let storage = new nds_core_1.NDSCore();
    const setItem = async (items, options) => {
        if (is_any_type_1.assert.isBoolean((0, validator_1.propertyValidator)(options))) {
            if (is_any_type_1.assert.isArray(items)) {
                const matchItem = await storage.match();
                if (matchItem === false) {
                    return Promise.resolve(await storage.set(items));
                }
                else {
                    return Promise.resolve(await storage.set(items));
                }
            }
            else {
                return Promise.resolve(false);
            }
        }
    };
    exports.setItem = setItem;
    const getItem = async (key, options) => {
        if (is_any_type_1.assert.isBoolean((0, validator_1.propertyValidator)(options))) {
            const getItem = await storage.get(key);
            if (!is_any_type_1.assert.isFunction(getItem) || !is_any_type_1.assert.isPromise(getItem) || !is_any_type_1.assert.isNull(getItem) || !is_any_type_1.assert.isUndefined(getItem)) {
                return Promise.resolve(getItem);
            }
            else {
                return Promise.resolve(undefined);
            }
        }
    };
    exports.getItem = getItem;
    const removeItem = async (key, options) => {
        if (is_any_type_1.assert.isBoolean((0, validator_1.propertyValidator)(options))) {
            const removeItem = await storage.remove(key);
            if (removeItem) {
                return Promise.resolve(removeItem);
            }
            else {
                return Promise.resolve(false);
            }
        }
    };
    exports.removeItem = removeItem;
    const clearItem = async (options) => {
        if (is_any_type_1.assert.isBoolean((0, validator_1.propertyValidator)(options))) {
            const clearItem = await storage.clear();
            if (clearItem) {
                return Promise.resolve(clearItem);
            }
            else {
                return Promise.resolve(false);
            }
        }
    };
    exports.clearItem = clearItem;
    const allKeysItem = async (options) => {
        if (is_any_type_1.assert.isBoolean((0, validator_1.propertyValidator)(options))) {
            const allKeysItem = await storage.allKeys();
            if (allKeysItem.length > 0) {
                return Promise.resolve(allKeysItem);
            }
            else {
                return Promise.resolve([]);
            }
        }
    };
    exports.allKeysItem = allKeysItem;
    const keysItem = async (key, options) => {
        if (is_any_type_1.assert.isBoolean((0, validator_1.propertyValidator)(options))) {
            const keyItem = await storage.keys(key);
            if (!is_any_type_1.assert.isFunction(keyItem) || !is_any_type_1.assert.isPromise(keyItem) || !is_any_type_1.assert.isNull(keyItem) || !is_any_type_1.assert.isUndefined(keyItem)) {
                return Promise.resolve(keyItem);
            }
            else {
                return Promise.resolve(undefined);
            }
        }
    };
    exports.keysItem = keysItem;
});
